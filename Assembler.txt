DATA TYPES: 



En la parte de .data, siempre que tenemos una etiqueta como x: .byte 
entonces le estamos diciendo que en ese espacio en memoria voy a guardarr solo datos tipo byte, es decir, que ocupan 8 bits
EPP: TODO ESTO SE TRATA DE ASIGNAR CUANTO ESPACIO EN MEMORIA TENDRAN LOS DATOS. 


Tipos de datos de ATT y su valor en memoria: 


| Directiva  | Tamaño            | Descripción                                   |
| ---------- | ----------------- | --------------------------------------------- |
| `.byte`    | 1 byte (8 bits)   | Entero pequeño (0–255 o -128–127)             |
| `.word`    | 2 bytes (16 bits) | Entero mediano (0–65535 o -32768–32767)       |
| `.long`    | 4 bytes (32 bits) | Entero común (como `int` en C)                |
| `.quad`    | 8 bytes (64 bits) | Entero grande (como `long long`)              |
| `.ascii`   | N bytes           | Cadena de caracteres, **sin terminador**      |
| `.asciz`   | N+1 bytes         | Cadena de caracteres, **con terminador `\0`** |
| `.string`  | N+1 bytes         | Igual a `.asciz`                              |
| `.float`   | 4 bytes           | Número flotante (IEEE 754, tipo `float`)      |
| `.double`  | 8 bytes           | Número flotante (IEEE 754, tipo `double`)     |
| `.zero N`  | N bytes           | Rellena con N ceros                           |
| `.space N` | N bytes           | Reserva N bytes (contenido sin definir)       |



Anotaciones: 
1. Se salta el valor de tres bytes.




------------------------------------------- EJEMPLO --------------------------------------------------------------

.data

    x: .byte 0x66, 0x66, 0x3d, 0xc2 // decimos que tenemos un valor en memoria que va a guardar bytes, entonces, x apunta al primero de los bytes y ya despues, los que vienen fisicamente despus de x son lo0s otros valores, como un arreglo. 
// x -> 0x66 | 0x66 | 0x3d | 0xc2 |, en esta arquitectura de 32 bits ATT ASM, los valores se guardan en little endian, es decir que el primero que le paso es el de menor valor, y luego el pc cuando lo interprete entonces le cambia el orden: 

x: .byte 0x66, 0x66, 0x3d, 0xc2

0xC2 0x3D 0x66 0x66
↑    ↑    ↑    ↑
MSB        ...   LSB

entonces internamente el número es: 
0xC2-3D-66-66


    y1 : .byte 0x3d, 0xc2
    y2: .byte 0x66, 0x66
    z1: .byte 0xc2
    z2: .byte 0x3d
    z3: .byte 0x66
    z4: .byte 0x66
    
    fmtux: .string "n: %u\n" //formato sin signo
    fmtsx: .string "n: %d\n"  //formato con signo
    fmtf: .asciz "f: %f\n"
    
.text
.global main
main:

    subq $8, %rsp
    
    ## 4 bytes con signo
    
    movl x, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf

    ## 4 bytes sin signo
    
    movl x, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf
    
    ## 2 bytes con signo
    
    movswl y1, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf    
    
    movswl y2, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf
    
    ## 2 bytes sin signo
    
    movzwl y1, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf    
    
    movzwl y2, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf
    
    ## 1 byte con signo
    
    movsbl z1, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf    
    
    movsbl z2, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf    
    
    movsbl z3, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf    
    
    movsbl z4, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf 

    ## 1 byte sin signo
    
    movzbl z1, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf    
    
    movzbl z2, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf    
    
    movzbl z3, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf    
    
    movzbl z4, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf 
    
    ## 4 bytes a flotante
    
    movss x, %xmm0                       
    cvtss2sd %xmm0, %xmm0               

    movl $fmtf, %edi          
    movl $1, %eax                       
    call printf

	xor	%eax, %eax
	
	add $8, %rsp
	ret









