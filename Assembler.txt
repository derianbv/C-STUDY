DATA TYPES: 

| Directiva | Tamaño (bytes) | Significado                   |
| --------- | -------------- | ----------------------------- |
| `.byte`   | 1 byte         | 8 bits (0 a 255 o -128 a 127) |
| `.word`   | 2 bytes        | 16 bits                       |
| `.long`   | 4 bytes        | 32 bits                       |
| `.quad`   | 8 bytes        | 64 bits                       |
| `.ascii`  | N bytes        | Cadena de caracteres sin `\0` |
| `.asciz`  | N+1 bytes      | Cadena con terminador `\0`    |
| `.string` | N+1 bytes      | Alias de `.asciz`             |


En la parte de .data, siempre que tenemos una etiqueta como x: .byte 







------------------------------------------- EJEMPLO --------------------------------------------------------------

.data

    x: .byte 0x66, 0x66, 0x3d, 0xc2 // decimos que tenemos un valor en memoria que va a guardar bytes, entonces, x apunta al primero de los bytes y ya despues, los que vienen fisicamente despus de x son lo0s otros valores, como un arreglo. 
// x -> 0x66 | 0x66 | 0x3d | 0xc2 |, en esta arquitectura de 32 bits ATT ASM, los valores se guardan en little endian, es decir que el primero que le paso es el de menor valor, y luego el pc cuando lo interprete entonces le cambia el orden: 

x: .byte 0x66, 0x66, 0x3d, 0xc2

0xC2 0x3D 0x66 0x66
↑    ↑    ↑    ↑
MSB        ...   LSB

entonces internamente el número es: 
0xC2-3D-66-66


    y1 : .byte 0x3d, 0xc2
    y2: .byte 0x66, 0x66
    z1: .byte 0xc2
    z2: .byte 0x3d
    z3: .byte 0x66
    z4: .byte 0x66
    
    fmtux: .string "n: %u\n" //formato sin signo
    fmtsx: .string "n: %d\n"  //formato con signo
    fmtf: .asciz "f: %f\n"
    
.text
.global main
main:

    subq $8, %rsp
    
    ## 4 bytes con signo
    
    movl x, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf

    ## 4 bytes sin signo
    
    movl x, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf
    
    ## 2 bytes con signo
    
    movswl y1, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf    
    
    movswl y2, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf
    
    ## 2 bytes sin signo
    
    movzwl y1, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf    
    
    movzwl y2, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf
    
    ## 1 byte con signo
    
    movsbl z1, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf    
    
    movsbl z2, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf    
    
    movsbl z3, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf    
    
    movsbl z4, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf 

    ## 1 byte sin signo
    
    movzbl z1, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf    
    
    movzbl z2, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf    
    
    movzbl z3, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf    
    
    movzbl z4, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf 
    
    ## 4 bytes a flotante
    
    movss x, %xmm0                       
    cvtss2sd %xmm0, %xmm0               

    movl $fmtf, %edi          
    movl $1, %eax                       
    call printf

	xor	%eax, %eax
	
	add $8, %rsp
	ret









