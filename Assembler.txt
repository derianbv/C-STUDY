----------------------------------------------------------DATA TYPES: ------------------------------------------ 



En la parte de .data, siempre que tenemos una etiqueta como x: .byte 
entonces le estamos diciendo que en ese espacio en memoria voy a guardarr solo datos tipo byte, es decir, que ocupan 8 bits
EPP: TODO ESTO SE TRATA DE ASIGNAR CUANTO ESPACIO EN MEMORIA TENDRAN LOS DATOS. 


Tipos de datos de ATT y su valor en memoria: 


| Directiva ASM | Tama√±o (bytes) | Descripci√≥n                       | Nombre en Calculadora Windows |
| ------------- | -------------- | --------------------------------- | ----------------------------- |
| `.byte`       | 1              | Entero peque√±o (8 bits)           | Byte                          |
| `.word`       | 2              | Entero mediano (16 bits)          | Word                          |
| `.long`       | 4              | Entero com√∫n (32 bits)            | Dword (Double Word)           |
| `.quad`       | 8              | Entero grande (64 bits)           | Qword (Quad Word)             |
| `.ascii`      | N              | Cadena sin terminador null        | ‚Äî                             |
| `.asciz`      | N+1            | Cadena terminada en null          | ‚Äî                             |
| `.string`     | N+1            | Alias de `.asciz`                 | ‚Äî                             |
| `.float`      | 4              | N√∫mero flotante (IEEE 754 float)  | ‚Äî                             |
| `.double`     | 8              | N√∫mero flotante (IEEE 754 double) | ‚Äî                             |
| `.zero N`     | N              | N bytes rellenos con cero         | ‚Äî                             |
| `.space N`    | N              | Reserva N bytes sin inicializar   | ‚Äî                             |



Anotaciones: 
1. Se salta el valor de tres bytes.
2. La diferencia entre cadenas de texto con terminador y sin terminador se basa en que una guarda un dato con un 0x00 (0 en decimal) para indicar que ah√≠ termin√≥ la cadena de texto. Si no tiene terminador es como no poner pared o bandera que inidique que esos bits son los de la cadena: 

1. Cadena sin terminador (.ascii)

.ascii "Hola"

-En memoria: 
'H' 'o' 'l' 'a'
0x48 0x6F 0x6C 0x61

luego de eso siguen otros bits, los que sea que este usando la memoria en ese momento. 



2. Cadena con terminador (.asciz o .string): 

.asciz 'H' 'o' 'l' 'a': 
-En memoria: (se a√±ade un 0). 
'H' 'o' 'l' 'a' '\0'
0x48 0x6F 0x6C 0x61 0x00


------------------------------------------- EJEMPLO --------------------------------------------------------------

.data

    x: .byte 0x66, 0x66, 0x3d, 0xc2 // decimos que tenemos un valor en memoria que va a guardar bytes, entonces, x apunta al primero de los bytes y ya despues, los que vienen fisicamente despus de x son lo0s otros valores, como un arreglo. 
// x -> 0x66 | 0x66 | 0x3d | 0xc2 |, en esta arquitectura de 32 bits ATT ASM, los valores se guardan en little endian, es decir que el primero que le paso es el de menor valor, y luego el pc cuando lo interprete entonces le cambia el orden: 

x: .byte 0x66, 0x66, 0x3d, 0xc2

0xC2 0x3D 0x66 0x66
‚Üë    ‚Üë    ‚Üë    ‚Üë
MSB        ...   LSB

entonces internamente el n√∫mero es: 
0xC2-3D-66-66

0xC2 (m√°s significativo)
0x3D
0x66
0x66 (menos significativo)

‚Üí 0xC23D6666

En la direcci√≥n etiquetada como x, guarda:

Byte 0: 0x66 ‚Üê üìç esta es la direcci√≥n x

Byte 1: 0x66

Byte 2: 0x3D

Byte 3: 0xC2
EPP: EN CASCADA DE MENOR A MAYOR (LITTLE ENDIAN). 

    y1 : .byte 0x3d, 0xc2
    y2: .byte 0x66, 0x66
    z1: .byte 0xc2
    z2: .byte 0x3d
    z3: .byte 0x66
    z4: .byte 0x66
    
    fmtux: .string "n: %u\n" //formato sin signo
    fmtsx: .string "n: %d\n"  //formato con signo
    fmtf: .asciz "f: %f\n"
    
.text
.global main
main:

    subq $8, %rsp
    
    ## 4 bytes con signo
    
    movl x, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf

    ## 4 bytes sin signo
    
    movl x, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf
    
    ## 2 bytes con signo
    
    movswl y1, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf    
    
    movswl y2, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf
    
    ## 2 bytes sin signo
    
    movzwl y1, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf    
    
    movzwl y2, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf
    
    ## 1 byte con signo
    
    movsbl z1, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf    
    
    movsbl z2, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf    
    
    movsbl z3, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf    
    
    movsbl z4, %esi
    movl $fmtsx, %edi
    movl $0, %eax
    call printf 

    ## 1 byte sin signo
    
    movzbl z1, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf    
    
    movzbl z2, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf    
    
    movzbl z3, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf    
    
    movzbl z4, %esi
    movl $fmtux, %edi
    movl $0, %eax
    call printf 
    
    ## 4 bytes a flotante
    
    movss x, %xmm0                       
    cvtss2sd %xmm0, %xmm0               

    movl $fmtf, %edi          
    movl $1, %eax                       
    call printf

	xor	%eax, %eax
	
	add $8, %rsp
	ret









